package main

import (
	"encoding/json"
	"os/exec"
	"strings"
	"testing"

	"github.com/Use-Tusk/fence/internal/config"
)

func TestBuildInitConfig_DefaultTemplate(t *testing.T) {
	cfg, err := buildInitConfig("", false)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	if cfg == nil {
		t.Fatal("expected config, got nil")
	}

	if cfg.Extends != "code" {
		t.Fatalf("expected extends=code, got %q", cfg.Extends)
	}
}

func TestBuildInitConfig_Minimal(t *testing.T) {
	cfg, err := buildInitConfig("", true)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	if cfg == nil {
		t.Fatal("expected config, got nil")
	}

	if cfg.Extends != "" {
		t.Fatalf("expected no extends for minimal config, got %q", cfg.Extends)
	}
}

func TestBuildInitConfig_CustomTemplate(t *testing.T) {
	cfg, err := buildInitConfig("local-dev-server", false)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	if cfg == nil {
		t.Fatal("expected config, got nil")
	}

	if cfg.Extends != "local-dev-server" {
		t.Fatalf("expected extends=local-dev-server, got %q", cfg.Extends)
	}
}

func TestBuildInitConfig_InvalidTemplate(t *testing.T) {
	cfg, err := buildInitConfig("not-a-template", false)
	if err == nil {
		t.Fatal("expected error, got nil")
	}
	if cfg != nil {
		t.Fatal("expected nil config on error")
	}
}

func TestRenderInitConfigJSON_Default(t *testing.T) {
	cfg, err := buildInitConfig("", false)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	data, err := renderInitConfigJSON(cfg, false)
	if err != nil {
		t.Fatalf("unexpected marshal error: %v", err)
	}

	var parsed map[string]any
	if err := json.Unmarshal(data, &parsed); err != nil {
		t.Fatalf("expected valid JSON: %v", err)
	}

	if got, ok := parsed["extends"].(string); !ok || got != "code" {
		t.Fatalf("expected extends=code, got %#v", parsed["extends"])
	}

	if _, hasNetwork := parsed["network"]; hasNetwork {
		t.Fatal("expected compact JSON without empty network block")
	}
}

func TestRenderInitConfigJSON_Scaffold(t *testing.T) {
	cfg, err := buildInitConfig("", false)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	data, err := renderInitConfigJSON(cfg, true)
	if err != nil {
		t.Fatalf("unexpected marshal error: %v", err)
	}

	if !strings.Contains(string(data), "\n  \"network\"") {
		t.Fatal("expected indented JSON scaffold output")
	}

	var parsed struct {
		Extends string `json:"extends"`
		Network struct {
			AllowedDomains []string `json:"allowedDomains"`
			DeniedDomains  []string `json:"deniedDomains"`
		} `json:"network"`
		Filesystem struct {
			AllowRead    []string `json:"allowRead"`
			AllowExecute []string `json:"allowExecute"`
			DenyRead     []string `json:"denyRead"`
			AllowWrite   []string `json:"allowWrite"`
			DenyWrite    []string `json:"denyWrite"`
		} `json:"filesystem"`
		Command struct {
			Deny  []string `json:"deny"`
			Allow []string `json:"allow"`
		} `json:"command"`
		SSH struct {
			AllowedHosts    []string `json:"allowedHosts"`
			DeniedHosts     []string `json:"deniedHosts"`
			AllowedCommands []string `json:"allowedCommands"`
			DeniedCommands  []string `json:"deniedCommands"`
		} `json:"ssh"`
	}

	if err := json.Unmarshal(data, &parsed); err != nil {
		t.Fatalf("expected valid scaffold JSON: %v", err)
	}

	if parsed.Extends != "code" {
		t.Fatalf("expected extends=code, got %q", parsed.Extends)
	}
	if len(parsed.Network.AllowedDomains) != 0 || len(parsed.Network.DeniedDomains) != 0 {
		t.Fatal("expected scaffold network arrays to be empty")
	}
	if len(parsed.Filesystem.AllowWrite) != 0 || len(parsed.Command.Deny) != 0 || len(parsed.SSH.AllowedHosts) != 0 {
		t.Fatal("expected scaffold arrays to be present and empty")
	}
}

func TestInitHeaderLines_WithExtends(t *testing.T) {
	cfg := &config.Config{Extends: "code"}
	lines := initHeaderLines(cfg)

	if len(lines) == 0 {
		t.Fatal("expected init header lines")
	}
	if !strings.Contains(lines[0], "fence config init") {
		t.Fatalf("expected init header text, got %q", lines[0])
	}
	if !strings.Contains(strings.Join(lines, "\n"), "Configuration reference: https://github.com/Use-Tusk/fence/blob/main/docs/configuration.md") {
		t.Fatal("expected configuration reference link in init headers")
	}
}

func TestFormatInitConfigWithComment(t *testing.T) {
	cfg := &config.Config{Extends: "code"}
	output := formatInitConfigWithComment([]byte("{\n  \"extends\": \"code\"\n}"), cfg)

	if !strings.HasPrefix(output, "// Starter config generated by `fence config init`") {
		t.Fatal("expected init comment header at top of file output")
	}
	if !strings.Contains(output, "\n{\n  \"extends\": \"code\"\n}\n") {
		t.Fatal("expected JSON body below comment header")
	}
}

func TestStartCommandWithSignalProxy_CleanupIsIdempotent(t *testing.T) {
	execCmd := exec.Command("sh", "-c", "exit 0")
	cleanup, err := startCommandWithSignalProxy(execCmd)
	if err != nil {
		t.Fatalf("startCommandWithSignalProxy() error = %v", err)
	}

	if err := execCmd.Wait(); err != nil {
		t.Fatalf("execCmd.Wait() error = %v", err)
	}

	cleanup()
	cleanup()
}
